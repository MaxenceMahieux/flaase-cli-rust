//! Environment variable management for applications.

use std::collections::BTreeMap;
use std::fs::{self, OpenOptions};
use std::io::Write;
use std::os::unix::fs::OpenOptionsExt;
use std::path::Path;

use crate::core::error::AppError;

/// Source of an environment variable.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EnvSource {
    /// User-defined variable.
    User,
    /// Auto-generated by Flaase (DATABASE_URL, REDIS_URL, etc.).
    Auto,
}

/// An environment variable with its source.
#[derive(Debug, Clone)]
pub struct EnvVar {
    pub key: String,
    pub value: String,
    pub source: EnvSource,
}

impl EnvVar {
    /// Returns a masked version of the value.
    pub fn masked_value(&self) -> String {
        if self.value.is_empty() {
            return String::new();
        }

        // Show non-sensitive values in plain text
        if self.is_non_sensitive() {
            return self.value.clone();
        }

        // Mask sensitive values
        let mask_len = self.value.len().min(22);
        "•".repeat(mask_len)
    }

    /// Returns true if the value is considered non-sensitive.
    fn is_non_sensitive(&self) -> bool {
        let key_upper = self.key.to_uppercase();
        let non_sensitive_keys = [
            "NODE_ENV",
            "DEBUG",
            "LOG_LEVEL",
            "PORT",
            "HOST",
            "TZ",
            "LANG",
            "LC_ALL",
        ];

        non_sensitive_keys.contains(&key_upper.as_str())
            || self.value == "true"
            || self.value == "false"
            || self.value == "production"
            || self.value == "development"
            || self.value == "staging"
    }
}

/// Manager for environment variables.
pub struct EnvManager;

impl EnvManager {
    /// Auto-generated variable keys.
    const AUTO_KEYS: &'static [&'static str] = &["DATABASE_URL", "REDIS_URL", "MONGODB_URL"];

    /// Loads environment variables from an app directory.
    pub fn load(app_dir: &Path) -> Result<Vec<EnvVar>, AppError> {
        let mut vars = Vec::new();

        // Load auto-generated vars first
        let auto_path = app_dir.join(".env.auto");
        if auto_path.exists() {
            let auto_vars = Self::parse_env_file(&auto_path)?;
            for (key, value) in auto_vars {
                vars.push(EnvVar {
                    key,
                    value,
                    source: EnvSource::Auto,
                });
            }
        }

        // Load user vars (these don't override auto vars)
        let user_path = app_dir.join(".env");
        if user_path.exists() {
            let user_vars = Self::parse_env_file(&user_path)?;
            for (key, value) in user_vars {
                // Skip if already defined as auto
                if !vars.iter().any(|v| v.key == key) {
                    vars.push(EnvVar {
                        key,
                        value,
                        source: EnvSource::User,
                    });
                }
            }
        }

        // Sort by key
        vars.sort_by(|a, b| a.key.cmp(&b.key));

        Ok(vars)
    }

    /// Loads only user-defined environment variables.
    pub fn load_user(app_dir: &Path) -> Result<BTreeMap<String, String>, AppError> {
        let user_path = app_dir.join(".env");
        if user_path.exists() {
            Self::parse_env_file(&user_path)
        } else {
            Ok(BTreeMap::new())
        }
    }

    /// Saves user-defined environment variables.
    /// Note: Does not filter out any keys to preserve backwards compatibility
    /// with apps that have auto-generated vars in .env (before .env.auto existed).
    pub fn save_user(app_dir: &Path, vars: &BTreeMap<String, String>) -> Result<(), AppError> {
        let user_path = app_dir.join(".env");

        let mut content = String::new();
        for (key, value) in vars {
            content.push_str(&format!("{}={}\n", key, Self::escape_value(value)));
        }

        Self::write_env_file(&user_path, &content)
    }

    /// Sets one or more environment variables.
    pub fn set(app_dir: &Path, assignments: &[(String, String)]) -> Result<usize, AppError> {
        let mut vars = Self::load_user(app_dir)?;
        let mut count = 0;

        for (key, value) in assignments {
            // Validate key
            Self::validate_key(key)?;

            // Check if trying to override auto var
            if Self::AUTO_KEYS.contains(&key.as_str()) {
                return Err(AppError::Validation(format!(
                    "'{}' is auto-generated and cannot be modified",
                    key
                )));
            }

            vars.insert(key.clone(), value.clone());
            count += 1;
        }

        Self::save_user(app_dir, &vars)?;
        Ok(count)
    }

    /// Removes an environment variable.
    pub fn remove(app_dir: &Path, key: &str) -> Result<bool, AppError> {
        // Check if trying to remove auto var
        if Self::AUTO_KEYS.contains(&key) {
            return Err(AppError::Validation(format!(
                "'{}' is auto-generated and cannot be removed",
                key
            )));
        }

        let mut vars = Self::load_user(app_dir)?;

        if vars.remove(key).is_some() {
            Self::save_user(app_dir, &vars)?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// Parses a KEY=value assignment string.
    pub fn parse_assignment(s: &str) -> Result<(String, String), AppError> {
        let parts: Vec<&str> = s.splitn(2, '=').collect();

        if parts.len() != 2 {
            return Err(AppError::Validation(format!(
                "Invalid format '{}'. Expected KEY=value",
                s
            )));
        }

        let key = parts[0].trim().to_string();
        let value = parts[1].trim().to_string();

        Self::validate_key(&key)?;

        Ok((key, value))
    }

    /// Validates an environment variable key.
    fn validate_key(key: &str) -> Result<(), AppError> {
        if key.is_empty() {
            return Err(AppError::Validation(
                "Environment variable key cannot be empty".into(),
            ));
        }

        // Must start with a letter or underscore
        let first = key.chars().next().unwrap();
        if !first.is_ascii_alphabetic() && first != '_' {
            return Err(AppError::Validation(format!(
                "Key '{}' must start with a letter or underscore",
                key
            )));
        }

        // Must contain only alphanumeric and underscore
        if !key.chars().all(|c| c.is_ascii_alphanumeric() || c == '_') {
            return Err(AppError::Validation(format!(
                "Key '{}' must contain only letters, numbers, and underscores",
                key
            )));
        }

        Ok(())
    }

    /// Parses an env file into a map.
    fn parse_env_file(path: &Path) -> Result<BTreeMap<String, String>, AppError> {
        let content = fs::read_to_string(path)
            .map_err(|e| AppError::Config(format!("Failed to read env file: {}", e)))?;

        let mut vars = BTreeMap::new();

        for line in content.lines() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Parse KEY=value
            if let Some(pos) = line.find('=') {
                let key = line[..pos].trim().to_string();
                let value = Self::unescape_value(line[pos + 1..].trim());
                vars.insert(key, value);
            }
        }

        Ok(vars)
    }

    /// Escapes a value for storage in an env file.
    fn escape_value(value: &str) -> String {
        // If value contains special chars, quote it
        if value.contains(' ')
            || value.contains('"')
            || value.contains('\'')
            || value.contains('$')
            || value.contains('\n')
        {
            // Use double quotes and escape internal quotes
            format!("\"{}\"", value.replace('\\', "\\\\").replace('"', "\\\""))
        } else {
            value.to_string()
        }
    }

    /// Unescapes a value from an env file.
    fn unescape_value(value: &str) -> String {
        let value = value.trim();

        // Remove surrounding quotes
        if (value.starts_with('"') && value.ends_with('"'))
            || (value.starts_with('\'') && value.ends_with('\''))
        {
            let inner = &value[1..value.len() - 1];
            return inner.replace("\\\"", "\"").replace("\\\\", "\\");
        }

        value.to_string()
    }

    /// Writes content to an env file with restricted permissions.
    fn write_env_file(path: &Path, content: &str) -> Result<(), AppError> {
        let mut file = OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .mode(0o600)
            .open(path)
            .map_err(|e| AppError::Config(format!("Failed to create env file: {}", e)))?;

        file.write_all(content.as_bytes())
            .map_err(|e| AppError::Config(format!("Failed to write env file: {}", e)))?;

        Ok(())
    }

    /// Returns the path to the user env file for editing.
    pub fn get_user_env_path(app_dir: &Path) -> std::path::PathBuf {
        app_dir.join(".env")
    }

    /// Gets the user's preferred editor.
    pub fn get_editor() -> String {
        std::env::var("EDITOR")
            .or_else(|_| std::env::var("VISUAL"))
            .unwrap_or_else(|_| "nano".to_string())
    }

    /// Counts user and auto variables.
    pub fn count(vars: &[EnvVar]) -> (usize, usize) {
        let user_count = vars.iter().filter(|v| v.source == EnvSource::User).count();
        let auto_count = vars.iter().filter(|v| v.source == EnvSource::Auto).count();
        (user_count, auto_count)
    }

    /// Loads environment variables from a specific file path.
    pub fn load_from_file(path: &Path) -> Result<Vec<EnvVar>, AppError> {
        if !path.exists() {
            return Ok(Vec::new());
        }

        let vars_map = Self::parse_env_file(path)?;
        let mut vars: Vec<EnvVar> = vars_map
            .into_iter()
            .map(|(key, value)| EnvVar {
                key,
                value,
                source: EnvSource::User,
            })
            .collect();

        vars.sort_by(|a, b| a.key.cmp(&b.key));
        Ok(vars)
    }

    /// Sets environment variables to a specific file path.
    pub fn set_to_file(path: &Path, assignments: &[(String, String)]) -> Result<usize, AppError> {
        // Load existing vars from file
        let mut vars = if path.exists() {
            Self::parse_env_file(path)?
        } else {
            BTreeMap::new()
        };

        let mut count = 0;
        for (key, value) in assignments {
            Self::validate_key(key)?;
            vars.insert(key.clone(), value.clone());
            count += 1;
        }

        // Write back to file
        let mut content = String::new();
        for (key, value) in &vars {
            content.push_str(&format!("{}={}\n", key, Self::escape_value(value)));
        }

        Self::write_env_file(path, &content)?;
        Ok(count)
    }

    /// Removes an environment variable from a specific file path.
    pub fn remove_from_file(path: &Path, key: &str) -> Result<bool, AppError> {
        if !path.exists() {
            return Ok(false);
        }

        let mut vars = Self::parse_env_file(path)?;

        if vars.remove(key).is_some() {
            let mut content = String::new();
            for (k, v) in &vars {
                content.push_str(&format!("{}={}\n", k, Self::escape_value(v)));
            }
            Self::write_env_file(path, &content)?;
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// Lists all environment files for an app directory.
    pub fn list_environments(app_dir: &Path) -> Result<Vec<String>, AppError> {
        let mut environments = Vec::new();

        // Check default .env
        if app_dir.join(".env").exists() {
            environments.push("production".to_string());
        }

        // Find .env.* files
        if let Ok(entries) = fs::read_dir(app_dir) {
            for entry in entries.flatten() {
                let name = entry.file_name().to_string_lossy().to_string();
                if name.starts_with(".env.") && name != ".env.auto" {
                    let env_name = name.trim_start_matches(".env.").to_string();
                    if !env_name.is_empty() && env_name != "auto" {
                        environments.push(env_name);
                    }
                }
            }
        }

        environments.sort();
        Ok(environments)
    }

    /// Copies environment variables from one file to another.
    pub fn copy_env_file(from_path: &Path, to_path: &Path) -> Result<usize, AppError> {
        if !from_path.exists() {
            return Err(AppError::Config(format!(
                "Source environment file does not exist: {}",
                from_path.display()
            )));
        }

        let vars = Self::parse_env_file(from_path)?;
        let count = vars.len();

        let mut content = String::new();
        for (key, value) in &vars {
            content.push_str(&format!("{}={}\n", key, Self::escape_value(value)));
        }

        Self::write_env_file(to_path, &content)?;
        Ok(count)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_assignment() {
        let (key, value) = EnvManager::parse_assignment("API_KEY=sk-123").unwrap();
        assert_eq!(key, "API_KEY");
        assert_eq!(value, "sk-123");
    }

    #[test]
    fn test_parse_assignment_with_equals() {
        let (key, value) = EnvManager::parse_assignment("URL=http://example.com?foo=bar").unwrap();
        assert_eq!(key, "URL");
        assert_eq!(value, "http://example.com?foo=bar");
    }

    #[test]
    fn test_validate_key() {
        assert!(EnvManager::validate_key("API_KEY").is_ok());
        assert!(EnvManager::validate_key("_PRIVATE").is_ok());
        assert!(EnvManager::validate_key("KEY123").is_ok());

        assert!(EnvManager::validate_key("123KEY").is_err());
        assert!(EnvManager::validate_key("KEY-NAME").is_err());
        assert!(EnvManager::validate_key("").is_err());
    }

    #[test]
    fn test_escape_unescape() {
        let original = "hello world";
        let escaped = EnvManager::escape_value(original);
        assert_eq!(escaped, "\"hello world\"");

        let unescaped = EnvManager::unescape_value(&escaped);
        assert_eq!(unescaped, original);
    }

    #[test]
    fn test_masked_value() {
        let var = EnvVar {
            key: "API_KEY".to_string(),
            value: "sk-123456789".to_string(),
            source: EnvSource::User,
        };
        assert_eq!(var.masked_value(), "•".repeat(12));

        let var = EnvVar {
            key: "NODE_ENV".to_string(),
            value: "production".to_string(),
            source: EnvSource::User,
        };
        assert_eq!(var.masked_value(), "production");
    }
}
