use std::path::Path;

use crate::core::config::{ReverseProxyInfo, FLAASE_TRAEFIK_DYNAMIC_PATH, FLAASE_TRAEFIK_PATH};
use crate::core::context::ExecutionContext;
use crate::core::error::AppError;
use crate::providers::container::{ContainerConfig, ContainerRuntime, RestartPolicy};

/// Trait for reverse proxy operations.
/// Allows for different implementations (Traefik, Nginx, Caddy, etc.).
pub trait ReverseProxy {
    /// Returns the name of the reverse proxy.
    fn name(&self) -> &str;

    /// Returns the proxy type identifier for config.
    fn proxy_type(&self) -> &str;

    /// Checks if the reverse proxy is installed/running.
    fn is_installed(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<bool, AppError>;

    /// Gets the installed version.
    fn get_version(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<String, AppError>;

    /// Installs and starts the reverse proxy.
    fn install(
        &self,
        runtime: &dyn ContainerRuntime,
        email: &str,
        ctx: &ExecutionContext,
    ) -> Result<(), AppError>;

    /// Stops the reverse proxy.
    fn stop(&self, runtime: &dyn ContainerRuntime, ctx: &ExecutionContext) -> Result<(), AppError>;

    /// Restarts the reverse proxy.
    fn restart(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<(), AppError>;

    /// Checks if the reverse proxy is running.
    fn is_running(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<bool, AppError>;

    /// Gets proxy info for the server config.
    fn get_info(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<ReverseProxyInfo, AppError>;

    /// Creates configuration directories.
    fn create_config_dirs(&self, ctx: &ExecutionContext) -> Result<(), AppError>;

    /// Writes the static configuration.
    fn write_static_config(&self, email: &str, ctx: &ExecutionContext) -> Result<(), AppError>;

    /// Writes the dynamic configuration for an app.
    fn write_app_config(
        &self,
        app_name: &str,
        domain: &str,
        container_port: u16,
        ctx: &ExecutionContext,
    ) -> Result<(), AppError>;

    /// Removes the dynamic configuration for an app.
    fn remove_app_config(&self, app_name: &str, ctx: &ExecutionContext) -> Result<(), AppError>;
}

/// Traefik reverse proxy implementation.
pub struct TraefikProxy {
    container_name: String,
    image: String,
    network: String,
}

impl TraefikProxy {
    pub fn new() -> Self {
        Self {
            container_name: "flaase-traefik".to_string(),
            image: "traefik:v3.2".to_string(),
            network: "flaase-network".to_string(),
        }
    }

    /// Container name for Traefik.
    pub fn container_name(&self) -> &str {
        &self.container_name
    }

    /// Network name for Flaase containers.
    pub fn network_name(&self) -> &str {
        &self.network
    }

    /// Generates the static Traefik configuration.
    fn generate_static_config(&self, email: &str) -> String {
        format!(
            r#"# Traefik static configuration
# Generated by Flaase

api:
  dashboard: false

entryPoints:
  web:
    address: ":80"
    http:
      redirections:
        entryPoint:
          to: websecure
          scheme: https

  websecure:
    address: ":443"

providers:
  file:
    directory: /etc/traefik/dynamic
    watch: true

certificatesResolvers:
  letsencrypt:
    acme:
      email: {email}
      storage: /etc/traefik/acme.json
      httpChallenge:
        entryPoint: web

log:
  level: ERROR

accessLog: {{}}
"#,
            email = email
        )
    }

    /// Builds the container configuration for Traefik.
    fn build_container_config(&self) -> ContainerConfig {
        ContainerConfig::new(&self.container_name, &self.image)
            .port(80, 80)
            .port(443, 443)
            .volume(
                &format!("{}/traefik.yml", FLAASE_TRAEFIK_PATH),
                "/etc/traefik/traefik.yml",
            )
            .volume_readonly(FLAASE_TRAEFIK_DYNAMIC_PATH, "/etc/traefik/dynamic")
            .volume(
                &format!("{}/acme.json", FLAASE_TRAEFIK_PATH),
                "/etc/traefik/acme.json",
            )
            .network(&self.network)
            .restart(RestartPolicy::UnlessStopped)
            .label("flaase.managed", "true")
            .label("flaase.service", "traefik")
    }
}

impl Default for TraefikProxy {
    fn default() -> Self {
        Self::new()
    }
}

impl ReverseProxy for TraefikProxy {
    fn name(&self) -> &str {
        "Traefik"
    }

    fn proxy_type(&self) -> &str {
        "traefik"
    }

    fn is_installed(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<bool, AppError> {
        runtime.container_exists(&self.container_name, ctx)
    }

    fn get_version(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<String, AppError> {
        if !self.is_running(runtime, ctx)? {
            return Err(AppError::ReverseProxy("Traefik is not running".into()));
        }

        let output = ctx.run_command(
            "docker",
            &["exec", &self.container_name, "traefik", "version"],
        )?;

        // Parse version from output
        let version = output
            .stdout
            .lines()
            .find(|l| l.starts_with("Version:"))
            .and_then(|l| l.split_whitespace().nth(1))
            .map(|v| v.to_string())
            .unwrap_or_else(|| "unknown".to_string());

        Ok(version)
    }

    fn install(
        &self,
        runtime: &dyn ContainerRuntime,
        email: &str,
        ctx: &ExecutionContext,
    ) -> Result<(), AppError> {
        // Create config directories
        self.create_config_dirs(ctx)?;

        // Write static configuration
        self.write_static_config(email, ctx)?;

        // Create acme.json with proper permissions
        let acme_path = format!("{}/acme.json", FLAASE_TRAEFIK_PATH);
        if !Path::new(&acme_path).exists() || ctx.is_dry_run() {
            ctx.write_file(&acme_path, "")?;
            ctx.run_command("chmod", &["600", &acme_path])?;
        }

        // Ensure network exists
        runtime.create_network(&self.network, ctx)?;

        // Remove existing container if exists
        if runtime.container_exists(&self.container_name, ctx)? {
            runtime.remove_container(&self.container_name, ctx)?;
        }

        // Run Traefik container
        let config = self.build_container_config();
        runtime.run_container(&config, ctx)?;

        Ok(())
    }

    fn stop(&self, runtime: &dyn ContainerRuntime, ctx: &ExecutionContext) -> Result<(), AppError> {
        runtime.stop_container(&self.container_name, ctx)
    }

    fn restart(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<(), AppError> {
        self.stop(runtime, ctx)?;

        // Start again
        let config = self.build_container_config();
        runtime.run_container(&config, ctx)?;

        Ok(())
    }

    fn is_running(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<bool, AppError> {
        runtime.container_is_running(&self.container_name, ctx)
    }

    fn get_info(
        &self,
        runtime: &dyn ContainerRuntime,
        ctx: &ExecutionContext,
    ) -> Result<ReverseProxyInfo, AppError> {
        let version = self
            .get_version(runtime, ctx)
            .unwrap_or_else(|_| "unknown".to_string());
        Ok(ReverseProxyInfo {
            proxy_type: self.proxy_type().to_string(),
            version,
        })
    }

    fn create_config_dirs(&self, ctx: &ExecutionContext) -> Result<(), AppError> {
        ctx.create_dir(FLAASE_TRAEFIK_PATH)?;
        ctx.create_dir(FLAASE_TRAEFIK_DYNAMIC_PATH)?;
        Ok(())
    }

    fn write_static_config(&self, email: &str, ctx: &ExecutionContext) -> Result<(), AppError> {
        let config = self.generate_static_config(email);
        let path = format!("{}/traefik.yml", FLAASE_TRAEFIK_PATH);
        ctx.write_file(&path, &config)
    }

    fn write_app_config(
        &self,
        app_name: &str,
        domain: &str,
        container_port: u16,
        ctx: &ExecutionContext,
    ) -> Result<(), AppError> {
        use crate::templates::traefik::{generate_app_config, AppDomain};

        let domains = vec![AppDomain::new(domain, true)];
        let config = generate_app_config(app_name, &domains, container_port);
        let path = format!("{}/{}.yml", FLAASE_TRAEFIK_DYNAMIC_PATH, app_name);
        ctx.write_file(&path, &config)
    }

    fn remove_app_config(&self, app_name: &str, ctx: &ExecutionContext) -> Result<(), AppError> {
        let path = format!("{}/{}.yml", FLAASE_TRAEFIK_DYNAMIC_PATH, app_name);

        if ctx.is_dry_run() {
            crate::ui::info(&format!("[DRY-RUN] Remove {}", path));
            return Ok(());
        }

        if std::path::Path::new(&path).exists() {
            std::fs::remove_file(&path).map_err(|e| {
                AppError::ReverseProxy(format!("Failed to remove app config: {}", e))
            })?;
        }

        Ok(())
    }
}

/// Creates the appropriate reverse proxy.
/// Currently only Traefik is supported.
pub fn create_reverse_proxy() -> Box<dyn ReverseProxy> {
    Box::new(TraefikProxy::new())
}
