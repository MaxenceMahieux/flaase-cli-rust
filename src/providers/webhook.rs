//! Webhook handling for autodeploy functionality.

use crate::core::error::AppError;
use crate::core::{SecretsManager, FLAASE_BASE_PATH};

/// Path to the webhook service directory.
pub const FLAASE_WEBHOOK_PATH: &str = "/opt/flaase/webhook";

/// Webhook provider for managing autodeploy webhooks.
pub struct WebhookProvider;

impl WebhookProvider {
    /// Generates the full webhook URL for an app.
    pub fn webhook_url(domain: &str, webhook_path: &str) -> String {
        format!("https://{}/flaase/webhook/{}", domain, webhook_path)
    }

    /// Generates a unique webhook path for an app.
    pub fn generate_webhook_path(app_name: &str) -> String {
        // Use a combination of app name and random suffix
        let suffix = SecretsManager::generate_password(16);
        format!("{}-{}", app_name, suffix.to_lowercase())
    }

    /// Validates a webhook signature from GitHub.
    /// GitHub sends a X-Hub-Signature-256 header with the signature.
    pub fn validate_signature(payload: &[u8], signature: &str, secret: &str) -> bool {
        use hmac::{Hmac, Mac};
        use sha2::Sha256;

        type HmacSha256 = Hmac<Sha256>;

        // GitHub signature format: sha256=<hex_digest>
        let expected_prefix = "sha256=";
        if !signature.starts_with(expected_prefix) {
            return false;
        }

        let hex_sig = &signature[expected_prefix.len()..];

        // Compute HMAC-SHA256
        let mut mac = match HmacSha256::new_from_slice(secret.as_bytes()) {
            Ok(m) => m,
            Err(_) => return false,
        };
        mac.update(payload);

        // Compare with constant-time comparison
        let result = mac.finalize();
        let computed = hex::encode(result.into_bytes());

        // Constant-time comparison
        computed.len() == hex_sig.len()
            && computed
                .bytes()
                .zip(hex_sig.bytes())
                .fold(0u8, |acc, (a, b)| acc | (a ^ b))
                == 0
    }

    /// Generates the Traefik webhook router configuration.
    pub fn generate_traefik_webhook_config() -> String {
        r#"# Traefik configuration for Flaase webhook endpoint
# Generated by Flaase

http:
  routers:
    flaase-webhook:
      rule: "PathPrefix(`/flaase/webhook/`)"
      entryPoints:
        - websecure
      service: flaase-webhook
      priority: 100
      tls:
        certResolver: letsencrypt

  services:
    flaase-webhook:
      loadBalancer:
        servers:
          - url: "http://flaase-webhook:8080"
"#
        .to_string()
    }

    /// Generates the webhook service docker-compose configuration.
    pub fn generate_webhook_compose() -> String {
        String::from(
            r#"# Flaase Webhook Service
# Handles GitHub webhook events for autodeploy

version: '3.8'

services:
  webhook:
    container_name: flaase-webhook
    image: flaase/webhook:latest
    restart: unless-stopped
    environment:
      - FLAASE_BASE_PATH=/opt/flaase
      - WEBHOOK_PORT=8080
    volumes:
      - /opt/flaase:/opt/flaase:ro
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - flaase-network
    labels:
      - "flaase.managed=true"
      - "flaase.service=webhook"

networks:
  flaase-network:
    external: true
"#
        )
    }

    /// Writes the webhook Traefik configuration.
    pub fn write_traefik_config() -> Result<(), AppError> {
        let traefik_path = format!("{}/traefik/dynamic/flaase-webhook.yml", FLAASE_BASE_PATH);
        let config = Self::generate_traefik_webhook_config();

        std::fs::write(&traefik_path, config)
            .map_err(|e| AppError::Config(format!("Failed to write webhook Traefik config: {}", e)))
    }

    /// Checks if the webhook service is running.
    pub fn is_running() -> bool {
        // Check if the flaase-webhook container exists and is running
        std::process::Command::new("docker")
            .args(["ps", "-q", "-f", "name=flaase-webhook"])
            .output()
            .map(|o| !o.stdout.is_empty())
            .unwrap_or(false)
    }
}

/// Represents a GitHub webhook payload for push events.
#[derive(Debug, Clone)]
pub struct GitHubPushEvent {
    pub repository: String,
    pub branch: String,
    pub commit_sha: String,
    pub commit_message: String,
    pub pusher: String,
}

impl GitHubPushEvent {
    /// Parses a GitHub push event from JSON payload.
    pub fn from_json(json: &str) -> Result<Self, AppError> {
        let value: serde_json::Value = serde_json::from_str(json)
            .map_err(|e| AppError::Config(format!("Invalid webhook payload: {}", e)))?;

        // Extract ref (e.g., "refs/heads/main")
        let ref_str = value["ref"]
            .as_str()
            .ok_or_else(|| AppError::Config("Missing 'ref' in payload".into()))?;

        // Extract branch name from ref
        let branch = ref_str
            .strip_prefix("refs/heads/")
            .unwrap_or(ref_str)
            .to_string();

        // Extract repository name
        let repository = value["repository"]["full_name"]
            .as_str()
            .unwrap_or("unknown")
            .to_string();

        // Extract commit info
        let commit_sha = value["after"]
            .as_str()
            .unwrap_or("")
            .chars()
            .take(7)
            .collect();

        let commit_message = value["head_commit"]["message"]
            .as_str()
            .unwrap_or("")
            .lines()
            .next()
            .unwrap_or("")
            .to_string();

        let pusher = value["pusher"]["name"]
            .as_str()
            .unwrap_or("unknown")
            .to_string();

        Ok(Self {
            repository,
            branch,
            commit_sha,
            commit_message,
            pusher,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_webhook_path() {
        let path = WebhookProvider::generate_webhook_path("my-app");
        assert!(path.starts_with("my-app-"));
        assert!(path.len() > 10);
    }

    #[test]
    fn test_webhook_url() {
        let url = WebhookProvider::webhook_url("example.com", "my-app-abc123");
        assert_eq!(url, "https://example.com/flaase/webhook/my-app-abc123");
    }
}
