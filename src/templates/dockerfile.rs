//! Dockerfile templates for different application stacks.

use crate::core::app_config::{Framework, PackageManager, Stack, StackConfig};

/// Generates a Dockerfile for the given stack.
pub fn generate(stack: Stack, port: u16) -> String {
    match stack {
        Stack::NextJs => generate_nextjs(port),
        Stack::NodeJs => generate_nodejs(port),
        Stack::NestJs => generate_nestjs(port),
        Stack::Laravel => generate_laravel(port),
        Stack::Python => generate_python_default(port),
        Stack::Go => generate_go_default(port),
        Stack::Ruby => generate_ruby_default(port),
        Stack::Rust => generate_rust_default(port),
        Stack::Java => generate_java_default(port),
        Stack::Php => generate_php_default(port),
        Stack::Static => generate_static_default(port),
        Stack::Dockerfile => String::new(), // User provides their own
    }
}

/// Generates a Dockerfile with full stack configuration.
pub fn generate_with_config(stack: Stack, config: &StackConfig, port: u16) -> String {
    match stack {
        Stack::Python => generate_python(config, port),
        Stack::Go => generate_go(config, port),
        Stack::Ruby => generate_ruby(config, port),
        Stack::Rust => generate_rust(config, port),
        Stack::Java => generate_java(config, port),
        Stack::Php => generate_php(config, port),
        Stack::Static => generate_static(config, port),
        // For these stacks, we use the default templates
        Stack::NextJs => generate_nextjs(port),
        Stack::NodeJs => generate_nodejs(port),
        Stack::NestJs => generate_nestjs(port),
        Stack::Laravel => generate_laravel(port),
        Stack::Dockerfile => String::new(),
    }
}

/// Generates a Dockerfile for Next.js applications.
fn generate_nextjs(port: u16) -> String {
    format!(
        r#"# Next.js Dockerfile
# Generated by Flaase

FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \
  else echo "Lockfile not found." && exit 1; \
  fi

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

ENV NEXT_TELEMETRY_DISABLED=1

RUN \
  if [ -f yarn.lock ]; then yarn build; \
  elif [ -f package-lock.json ]; then npm run build; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm build; \
  else echo "Lockfile not found." && exit 1; \
  fi

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE {port}

ENV PORT={port}
ENV HOSTNAME="0.0.0.0"

CMD ["node", "server.js"]
"#,
        port = port
    )
}

/// Generates a Dockerfile for Node.js applications.
fn generate_nodejs(port: u16) -> String {
    format!(
        r#"# Node.js Dockerfile
# Generated by Flaase

FROM node:20-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \
  else npm install; \
  fi

# Copy source
COPY . .

# Build if there's a build script
RUN npm run build --if-present

# Production image
FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production

# Copy built application
COPY --from=builder /app ./

# Create non-root user
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nodeuser && \
    chown -R nodeuser:nodejs /app

USER nodeuser

EXPOSE {port}

CMD ["node", "dist/index.js"]
"#,
        port = port
    )
}

/// Generates a Dockerfile for NestJS applications.
fn generate_nestjs(port: u16) -> String {
    format!(
        r#"# NestJS Dockerfile
# Generated by Flaase

FROM node:20-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \
  elif [ -f package-lock.json ]; then npm ci; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \
  else npm install; \
  fi

# Copy source and build
COPY . .
RUN npm run build

# Production image
FROM node:20-alpine AS runner

WORKDIR /app

ENV NODE_ENV=production

# Copy package files and install production dependencies only
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \
  if [ -f yarn.lock ]; then yarn --frozen-lockfile --production; \
  elif [ -f package-lock.json ]; then npm ci --only=production; \
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile --prod; \
  else npm install --only=production; \
  fi

# Copy built application
COPY --from=builder /app/dist ./dist

# Create non-root user
RUN addgroup --system --gid 1001 nodejs && \
    adduser --system --uid 1001 nestuser && \
    chown -R nestuser:nodejs /app

USER nestuser

EXPOSE {port}

CMD ["node", "dist/main.js"]
"#,
        port = port
    )
}

/// Generates a Dockerfile for Laravel applications.
fn generate_laravel(port: u16) -> String {
    format!(
        r#"# Laravel Dockerfile
# Generated by Flaase

FROM php:8.3-fpm-alpine AS base

# Install system dependencies
RUN apk add --no-cache \
    git \
    curl \
    libpng-dev \
    libxml2-dev \
    zip \
    unzip \
    oniguruma-dev \
    postgresql-dev \
    nodejs \
    npm

# Install PHP extensions
RUN docker-php-ext-install pdo pdo_pgsql pdo_mysql mbstring exif pcntl bcmath gd

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Build stage
FROM base AS builder

WORKDIR /var/www

COPY composer.json composer.lock ./
RUN composer install --no-dev --no-scripts --no-autoloader

COPY . .
RUN composer dump-autoload --optimize

# Install npm dependencies and build assets
RUN if [ -f package.json ]; then npm ci && npm run build; fi

# Production image
FROM base AS runner

WORKDIR /var/www

# Copy application
COPY --from=builder /var/www ./

# Set permissions
RUN chown -R www-data:www-data /var/www/storage /var/www/bootstrap/cache

# Install Octane for high performance
RUN composer require laravel/octane --no-interaction || true
RUN php artisan octane:install --server=frankenphp || true

USER www-data

EXPOSE {port}

CMD ["php", "artisan", "octane:start", "--server=frankenphp", "--host=0.0.0.0", "--port={port}"]
"#,
        port = port
    )
}

/// Checks if a Dockerfile exists in the given directory.
pub fn exists(repo_dir: &std::path::Path) -> bool {
    repo_dir.join("Dockerfile").exists()
}

/// Returns the path to the Dockerfile in the repo.
pub fn path(repo_dir: &std::path::Path) -> std::path::PathBuf {
    repo_dir.join("Dockerfile")
}

// ============================================================================
// Python Dockerfiles
// ============================================================================

/// Default Python Dockerfile (pip + gunicorn).
fn generate_python_default(port: u16) -> String {
    generate_python(
        &StackConfig {
            version: Some("3.12".to_string()),
            package_manager: Some(PackageManager::Pip),
            start_command: Some(format!("gunicorn app:app --bind 0.0.0.0:{}", port)),
            ..Default::default()
        },
        port,
    )
}

/// Python Dockerfile with configuration.
fn generate_python(config: &StackConfig, port: u16) -> String {
    let version = config.version.as_deref().unwrap_or("3.12");
    let start_cmd = config.start_command.as_deref().unwrap_or("python main.py");

    let install_deps = match config.package_manager {
        Some(PackageManager::Poetry) => r#"
# Install poetry
RUN pip install poetry

# Copy dependency files
COPY pyproject.toml poetry.lock* ./

# Install dependencies
RUN poetry config virtualenvs.create false \
    && poetry install --no-interaction --no-ansi --only main"#,
        Some(PackageManager::Uv) => r#"
# Install uv
RUN pip install uv

# Copy dependency files
COPY pyproject.toml uv.lock* ./

# Install dependencies
RUN uv sync --frozen --no-dev"#,
        Some(PackageManager::Pipenv) => r#"
# Install pipenv
RUN pip install pipenv

# Copy dependency files
COPY Pipfile Pipfile.lock* ./

# Install dependencies
RUN pipenv install --system --deploy"#,
        _ => r#"
# Copy requirements
COPY requirements.txt .

# Install dependencies
RUN pip install --no-cache-dir -r requirements.txt"#,
    };

    let build_step = if let Some(ref build_cmd) = config.build_command {
        format!("\n# Build\nRUN {}\n", build_cmd)
    } else {
        String::new()
    };

    format!(
        r#"# Python Dockerfile
# Generated by Flaase

FROM python:{version}-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    libpq-dev \
    curl \
    && rm -rf /var/lib/apt/lists/*
{install_deps}

# Copy application
COPY . .
{build_step}
# Create non-root user
RUN useradd -m -r -u 1001 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE {port}

CMD {start_cmd}
"#,
        version = version,
        install_deps = install_deps,
        build_step = build_step,
        port = port,
        start_cmd = format_cmd(start_cmd),
    )
}

// ============================================================================
// Go Dockerfiles
// ============================================================================

/// Default Go Dockerfile.
fn generate_go_default(port: u16) -> String {
    generate_go(
        &StackConfig {
            version: Some("1.22".to_string()),
            start_command: Some("./main".to_string()),
            ..Default::default()
        },
        port,
    )
}

/// Go Dockerfile with configuration.
fn generate_go(config: &StackConfig, port: u16) -> String {
    let version = config.version.as_deref().unwrap_or("1.22");
    let build_cmd = config
        .build_command
        .as_deref()
        .unwrap_or("go build -ldflags='-w -s' -o main .");

    format!(
        r#"# Go Dockerfile
# Generated by Flaase

# Build stage
FROM golang:{version}-alpine AS builder

WORKDIR /app

# Install build dependencies
RUN apk add --no-cache git ca-certificates

# Download dependencies first (for caching)
COPY go.mod go.sum* ./
RUN go mod download

# Copy source and build
COPY . .
RUN CGO_ENABLED=0 GOOS=linux {build_cmd}

# Runtime stage
FROM alpine:latest

RUN apk --no-cache add ca-certificates tzdata

WORKDIR /app

# Copy binary from builder
COPY --from=builder /app/main .

# Create non-root user
RUN adduser -D -g '' -u 1001 appuser
USER appuser

EXPOSE {port}

CMD ["./main"]
"#,
        version = version,
        build_cmd = build_cmd,
        port = port,
    )
}

// ============================================================================
// Ruby Dockerfiles
// ============================================================================

/// Default Ruby Dockerfile.
fn generate_ruby_default(port: u16) -> String {
    generate_ruby(
        &StackConfig {
            version: Some("3.3".to_string()),
            framework: Some(Framework::Rails),
            start_command: Some(format!("rails server -b 0.0.0.0 -p {}", port)),
            ..Default::default()
        },
        port,
    )
}

/// Ruby Dockerfile with configuration.
fn generate_ruby(config: &StackConfig, port: u16) -> String {
    let version = config.version.as_deref().unwrap_or("3.3");
    let start_cmd = config
        .start_command
        .as_deref()
        .unwrap_or("ruby app.rb");

    let is_rails = matches!(config.framework, Some(Framework::Rails));

    let rails_setup = if is_rails {
        r#"
# Precompile assets (if assets exist)
RUN if [ -d "app/assets" ]; then \
      SECRET_KEY_BASE=placeholder bundle exec rails assets:precompile; \
    fi

# Precompile bootsnap (if available)
RUN bundle exec bootsnap precompile app/ lib/ || true"#
    } else {
        ""
    };

    format!(
        r#"# Ruby Dockerfile
# Generated by Flaase

FROM ruby:{version}-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    nodejs \
    npm \
    git \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Install gems
COPY Gemfile Gemfile.lock ./
RUN bundle config set --local without 'development test' \
    && bundle install --jobs 4 --retry 3

# Copy application
COPY . .
{rails_setup}
# Create non-root user
RUN useradd -m -r -u 1001 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE {port}

CMD {start_cmd}
"#,
        version = version,
        rails_setup = rails_setup,
        port = port,
        start_cmd = format_cmd(start_cmd),
    )
}

// ============================================================================
// Rust Dockerfiles
// ============================================================================

/// Default Rust Dockerfile.
fn generate_rust_default(port: u16) -> String {
    generate_rust(&StackConfig::default(), port)
}

/// Rust Dockerfile with configuration.
fn generate_rust(config: &StackConfig, port: u16) -> String {
    let binary_name = config
        .start_command
        .as_deref()
        .unwrap_or("./app")
        .trim_start_matches("./");

    format!(
        r#"# Rust Dockerfile
# Generated by Flaase

# Build stage with cargo-chef for dependency caching
FROM rust:latest AS chef
RUN cargo install cargo-chef
WORKDIR /app

# Planner - analyze dependencies
FROM chef AS planner
COPY . .
RUN cargo chef prepare --recipe-path recipe.json

# Builder - build dependencies then app
FROM chef AS builder
COPY --from=planner /app/recipe.json recipe.json
RUN cargo chef cook --release --recipe-path recipe.json
COPY . .
RUN cargo build --release

# Runtime - minimal image
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y --no-install-recommends \
    ca-certificates \
    libssl3 \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy binary - adjust name as needed
COPY --from=builder /app/target/release/{binary_name} ./app

# Create non-root user
RUN useradd -m -r -u 1001 appuser
USER appuser

EXPOSE {port}

CMD ["./app"]
"#,
        binary_name = binary_name,
        port = port,
    )
}

// ============================================================================
// Java Dockerfiles
// ============================================================================

/// Default Java Dockerfile (Maven + Spring Boot).
fn generate_java_default(port: u16) -> String {
    generate_java(
        &StackConfig {
            version: Some("21".to_string()),
            package_manager: Some(PackageManager::Maven),
            framework: Some(Framework::SpringBoot),
            ..Default::default()
        },
        port,
    )
}

/// Java Dockerfile with configuration.
fn generate_java(config: &StackConfig, port: u16) -> String {
    let version = config.version.as_deref().unwrap_or("21");

    let (build_image, build_cmd, jar_path) = match config.package_manager {
        Some(PackageManager::Gradle) => (
            format!("gradle:{}-jdk{}", version, version),
            "gradle bootJar --no-daemon -x test",
            "build/libs/*.jar",
        ),
        _ => (
            format!("maven:3-eclipse-temurin-{}", version),
            "mvn package -DskipTests",
            "target/*.jar",
        ),
    };

    format!(
        r#"# Java Dockerfile
# Generated by Flaase

# Build stage
FROM {build_image} AS builder

WORKDIR /app

# Copy build files
COPY . .

# Build
RUN {build_cmd}

# Runtime stage
FROM eclipse-temurin:{version}-jre-alpine

WORKDIR /app

# Copy JAR from builder
COPY --from=builder /app/{jar_path} app.jar

# Create non-root user
RUN adduser -D -g '' -u 1001 appuser
USER appuser

EXPOSE {port}

ENTRYPOINT ["java", "-jar", "app.jar"]
"#,
        build_image = build_image,
        build_cmd = build_cmd,
        jar_path = jar_path,
        version = version,
        port = port,
    )
}

// ============================================================================
// PHP Dockerfiles
// ============================================================================

/// Default PHP Dockerfile.
fn generate_php_default(port: u16) -> String {
    generate_php(
        &StackConfig {
            version: Some("8.3".to_string()),
            ..Default::default()
        },
        port,
    )
}

/// PHP Dockerfile with configuration.
fn generate_php(config: &StackConfig, port: u16) -> String {
    let version = config.version.as_deref().unwrap_or("8.3");
    let start_cmd = config
        .start_command
        .as_deref()
        .unwrap_or("php -S 0.0.0.0:8000 -t public");

    format!(
        r#"# PHP Dockerfile
# Generated by Flaase

FROM php:{version}-cli-alpine

WORKDIR /app

# Install system dependencies
RUN apk add --no-cache \
    git \
    curl \
    libpng-dev \
    libxml2-dev \
    zip \
    unzip \
    oniguruma-dev \
    postgresql-dev

# Install PHP extensions
RUN docker-php-ext-install pdo pdo_pgsql pdo_mysql mbstring exif pcntl bcmath gd

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Copy composer files and install dependencies
COPY composer.json composer.lock* ./
RUN composer install --no-dev --no-scripts --no-autoloader --prefer-dist

# Copy application
COPY . .

# Generate optimized autoloader
RUN composer dump-autoload --optimize

# Create non-root user
RUN adduser -D -g '' -u 1001 appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE {port}

CMD {start_cmd}
"#,
        version = version,
        port = port,
        start_cmd = format_cmd(start_cmd),
    )
}

// ============================================================================
// Static Dockerfiles
// ============================================================================

/// Default Static site Dockerfile.
fn generate_static_default(port: u16) -> String {
    generate_static(&StackConfig::default(), port)
}

/// Static site Dockerfile with configuration.
fn generate_static(config: &StackConfig, port: u16) -> String {
    let has_build = config.build_command.is_some();

    if has_build {
        let build_cmd = config.build_command.as_deref().unwrap_or("npm run build");

        format!(
            r#"# Static Site Dockerfile
# Generated by Flaase

# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
RUN npm ci

# Copy source and build
COPY . .
RUN {build_cmd}

# Runtime stage
FROM nginx:alpine

# Copy built files
COPY --from=builder /app/dist /usr/share/nginx/html

# Custom nginx config for SPA
RUN printf 'server {{\n\
    listen {port};\n\
    root /usr/share/nginx/html;\n\
    index index.html;\n\
    location / {{\n\
        try_files $uri $uri/ /index.html;\n\
    }}\n\
}}' > /etc/nginx/conf.d/default.conf

EXPOSE {port}

CMD ["nginx", "-g", "daemon off;"]
"#,
            build_cmd = build_cmd,
            port = port,
        )
    } else {
        format!(
            r#"# Static Site Dockerfile
# Generated by Flaase

FROM nginx:alpine

# Copy static files
COPY . /usr/share/nginx/html

# Custom nginx config for SPA
RUN printf 'server {{\n\
    listen {port};\n\
    root /usr/share/nginx/html;\n\
    index index.html;\n\
    location / {{\n\
        try_files $uri $uri/ /index.html;\n\
    }}\n\
}}' > /etc/nginx/conf.d/default.conf

EXPOSE {port}

CMD ["nginx", "-g", "daemon off;"]
"#,
            port = port,
        )
    }
}

// ============================================================================
// Helpers
// ============================================================================

/// Formats a command as a JSON array for CMD directive.
fn format_cmd(cmd: &str) -> String {
    // If it looks like a simple command, convert to exec form
    let parts: Vec<&str> = cmd.split_whitespace().collect();
    if parts.len() <= 5 && !cmd.contains('|') && !cmd.contains('>') && !cmd.contains('&') {
        let json_parts: Vec<String> = parts.iter().map(|p| format!("\"{}\"", p)).collect();
        format!("[{}]", json_parts.join(", "))
    } else {
        // Use shell form for complex commands
        format!("[\"/bin/sh\", \"-c\", \"{}\"]", cmd.replace('"', "\\\""))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_nextjs() {
        let dockerfile = generate(Stack::NextJs, 3000);
        assert!(dockerfile.contains("FROM node:20-alpine"));
        assert!(dockerfile.contains("EXPOSE 3000"));
        assert!(dockerfile.contains("Next.js"));
    }

    #[test]
    fn test_generate_laravel() {
        let dockerfile = generate(Stack::Laravel, 8000);
        assert!(dockerfile.contains("FROM php:8.3-fpm-alpine"));
        assert!(dockerfile.contains("EXPOSE 8000"));
        assert!(dockerfile.contains("Laravel"));
    }
}
