//! Traefik dynamic configuration templates for applications.
//! Used when deploying apps to generate routing rules.

/// Generates a Traefik dynamic configuration for an app.
pub fn generate_app_config(app_name: &str, domains: &[AppDomain], container_port: u16) -> String {
    let mut routers = String::new();
    let mut services = String::new();

    // Generate router for each domain
    for (i, domain) in domains.iter().enumerate() {
        let router_name = if i == 0 {
            app_name.to_string()
        } else {
            format!("{}-{}", app_name, i)
        };

        // HTTP router (for ACME challenge and redirect)
        routers.push_str(&format!(
            r#"    {router_name}-http:
      rule: "Host(`{domain}`)"
      entryPoints:
        - web
      service: {app_name}
      middlewares:
        - {app_name}-redirect-https
"#,
            router_name = router_name,
            domain = domain.domain,
            app_name = app_name
        ));

        // HTTPS router
        routers.push_str(&format!(
            r#"    {router_name}:
      rule: "Host(`{domain}`)"
      entryPoints:
        - websecure
      service: {app_name}
      tls:
        certResolver: letsencrypt
"#,
            router_name = router_name,
            domain = domain.domain,
            app_name = app_name
        ));

        // Add www routers if primary domain
        if domain.primary && !domain.domain.starts_with("www.") {
            // HTTP www router
            routers.push_str(&format!(
                r#"    {app_name}-www-http:
      rule: "Host(`www.{domain}`)"
      entryPoints:
        - web
      service: {app_name}
      middlewares:
        - {app_name}-redirect-https
"#,
                app_name = app_name,
                domain = domain.domain
            ));

            // HTTPS www router
            routers.push_str(&format!(
                r#"    {app_name}-www:
      rule: "Host(`www.{domain}`)"
      entryPoints:
        - websecure
      service: {app_name}
      tls:
        certResolver: letsencrypt
"#,
                app_name = app_name,
                domain = domain.domain
            ));
        }
    }

    // Generate service
    services.push_str(&format!(
        r#"    {app_name}:
      loadBalancer:
        servers:
          - url: "http://flaase-{app_name}-web:{port}"
"#,
        app_name = app_name,
        port = container_port
    ));

    // Generate middlewares
    let middlewares = format!(
        r#"  middlewares:
    {app_name}-redirect-https:
      redirectScheme:
        scheme: https
        permanent: true
"#,
        app_name = app_name
    );

    format!(
        r#"# Traefik dynamic configuration for {app_name}
# Generated by Flaase

http:
  routers:
{routers}
  services:
{services}
{middlewares}"#,
        app_name = app_name,
        routers = routers,
        services = services,
        middlewares = middlewares
    )
}

/// Domain configuration for an app.
#[derive(Debug, Clone)]
pub struct AppDomain {
    pub domain: String,
    pub primary: bool,
}

impl AppDomain {
    pub fn new(domain: &str, primary: bool) -> Self {
        Self {
            domain: domain.to_string(),
            primary,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_app_config() {
        let domains = vec![AppDomain::new("example.com", true)];
        let config = generate_app_config("my-app", &domains, 3000);

        // Check HTTPS router
        assert!(config.contains("my-app:"));
        assert!(config.contains("Host(`example.com`)"));
        assert!(config.contains("Host(`www.example.com`)"));
        assert!(config.contains("http://flaase-my-app-web:3000"));

        // Check HTTP router for ACME
        assert!(config.contains("my-app-http:"));
        assert!(config.contains("entryPoints:\n        - web"));

        // Check middleware
        assert!(config.contains("my-app-redirect-https:"));
        assert!(config.contains("redirectScheme:"));
    }
}
